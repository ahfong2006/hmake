<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docs &middot; HyperMake</title>

    <meta name="description" content="build without pre-requisites">

    <meta name="generator" content="Hugo 0.16" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Docs &middot; HyperMake">
    <meta name="twitter:description" content="build without pre-requisites">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Docs &middot; HyperMake">
    <meta property="og:description" content="build without pre-requisites">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://evo-cloud.github.com/hmake//css/syntax-highlighter.css">
    <link rel="stylesheet" href="http://evo-cloud.github.com/hmake//css/blog.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="HyperMake" href="http://evo-cloud.github.com/hmake//index.xml" />
</head>
<body>
<div class="banner pure-u-1 pure-u-md-1-4">
    <div class="banner-title">
        <h1 class="brand-title"><a href="http://evo-cloud.github.com/hmake/">HyperMake</a></h1>
        <h2 class="brand-tagline"> build without pre-requisites </h2>
    </div>
    <div class="banner-links">
        <nav class="nav">
            <ul class="nav-list">
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/evo-cloud/hmake "><i class="fa fa-github-alt"></i><span> github</span></a>
                </li>
                
                
            </ul>
        </nav>
    </div>
</div>


<div id="layout" class="pure-g">
    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/CommandLine/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="hypermake-command-line">HyperMake Command Line</h1>

<h2 id="usage">Usage</h2>

<pre><code>hmake [OPTIONS] [TARGETS]
</code></pre>

<p>There&rsquo;s no specific order between <code>OPTIONS</code> and <code>TARGETS</code>. All <code>OPTIONS</code> starts
with hyphen <code>-</code> while <code>TARGETS</code> doesn&rsquo;t.</p>

<h2 id="option-parsing-rules">Option Parsing Rules</h2>

<p>Common Unix command line option parsing rule is adopted:</p>

<ul>
<li>A short option starts with a single hyphen and then a single letter
(e.g. <code>-C</code>);
it may have a corresponding long option which starts with a double hyphen
followed by a word (or a few words concated with hyphen)
(e.g. <code>--chdir</code>, <code>--this-is-a-multi-word-opt</code>);</li>
<li>The value after a short option is provided as a separated argument
(after a space, e.g. <code>-C /tmp/proj</code>);
for long option, the value follows directly with <code>=</code> in the same argument
(e.g. <code>--chdir=/tmp/proj</code>);</li>
<li>Some option can be specified multiple times to provide a list or a map
(e.g.<br>
<em>list</em>: <code>--include=a.hmake --include=b.hmake</code> or <code>-I a.hmake -I b.hmake</code>;<br>
<em>map</em>: <code>--define=ARCH=x86_64 --define=OS=linux</code> or <code>-D ARCH=x86_64 -D OS=linux</code>
);</li>
<li>Bool options can be specified without value as <code>true</code> or prefixed by <code>no-</code> as
<code>false</code> (e.g. <code>--verbose</code> for <code>true</code>, <code>--no-verbose</code> for <code>false</code>);
It can also be specified with a value in the long option format
(e.g. <code>--verbose=true</code> or <code>--verbose=false</code>)</li>
</ul>

<h2 id="options">Options</h2>

<ul>
<li><code>--chdir=PATH, -C PATH</code>: Chdir to specified PATH first before doing anything</li>
<li><code>--file=FILE, -f FILE</code>: Override the default project file name <code>HyperMake</code></li>
<li><code>--include=FILE, -I FILE</code>: Include additional files (must be relative path under project root), can be specified multiple times</li>
<li><code>--property=key=value, -P key=value</code>: Define property in global <code>settings</code> section, <code>key</code> may include <code>.</code> to specify the hierarchy</li>
<li><code>--parallel=N, -p N</code>: Set maximum number of targets executed in parallel, 0 for auto, -1 for unlimited</li>
<li><code>--rebuild-all, -R</code>: Force rebuild all needed targets</li>
<li><code>--rebuild-target TARGET, -r TARGET</code>: Force rebuild specified target, this can repeat</li>
<li><code>--rebuild, -b</code>: Force rebuild targets specified on command line</li>
<li><code>--skip TARGET, -S TARGET</code>: Skip specified target (mark as Skipped), this can repeat</li>
<li><code>--exec, -x</code>: Execute a shell command in the context of a target.
The target name must be specified in <code>settings.exec-target</code> or use <code>--exec-with=TARGET</code>.
It&rsquo;s extremely useful to run arbitrary command in the context of a target.
It should come as the last option, as the rest command-line arguments will be
treated as command.</li>
</ul>

<p>For example:</p>

<pre><code class="language-sh">  hmake -x go version
  hmake -x   # enter an interactive shell inside the container
</code></pre>

<p>The commands parsing after <code>-x</code> is directly executed by <code>execvp</code> system call,
  not a command to be parsed by shell. So shell syntax like <code>&amp;&amp;</code> won&rsquo;t work.</p>

<p>To run as a shell command</p>

<pre><code class="language-sh">  hmake -x /bin/sh -c 'go version || echo &quot;go version failed&quot;'
</code></pre>

<ul>
<li><code>--exec-with=TARGET, -X TARGET</code>: Explicitly specify the target for <code>--exec</code> instead of
fetching from <code>settings.exec-target</code>.
As it implies <code>--exec</code>, it should come as the last option.</li>
</ul>

<p>For example:</p>

<pre><code class="language-sh">  hmake --exec-with=vendor go version
</code></pre>

<ul>
<li><code>--json</code>: Dump execution events to stdout each encoded in single line json</li>
<li><code>--summary, -s</code>: Show execution summary before exit</li>
<li><code>--quiet, -q</code>: Suppress output from each target</li>
<li><code>--rcfile|--no-rcfile</code>: Load .hmakerc inside project directories, default is true</li>
<li><code>--color|--no-color</code>: Explicitly specify print with color/no-color</li>
<li><code>--emoji|--no-emoji</code>: Explicitly specify print with emoji/no-emoji</li>
<li><code>--no-debug-log</code>: Disable writing debug log to <code>hmake.debug.log</code> in hmake state directory</li>
<li><code>--show-summary</code>: When specified, print previous execution summary and exit</li>
<li><code>--targets</code>: When specified, print list of target names and exit</li>
<li><code>--dryrun</code>: When specified, run targets as normal but without invoking execution drivers (simply mark task Success)</li>
<li><code>--version</code>: When specified, print version and exit</li>
</ul>

<p>The parsing of options stops when <code>--</code> is encountered. The rest of arguments will be
treated as target names. Except <code>--exec</code>/<code>--exec-with</code> already implies end of
options parsing, <code>--</code> should not be used.</p>

<blockquote>
<p>Note: <code>--exec</code>/<code>--exec-with</code> doesn&rsquo;t affect the last execution result of the
target, though it displays the result and updates the summary. So the target
may still be skipped next time if nothing changed.</p>
</blockquote>

<h2 id="exit-code">Exit Code</h2>

<ul>
<li>0: Success</li>
<li>1: One or more targets failed</li>
<li>2: Incorrect usage</li>
</ul>

    </div>
    
</section>

                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/Contribute/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="guidelines-for-contributing-to-hypermake">Guidelines for Contributing to HyperMake</h1>

<p>Thanks for using <em>HyperMake</em> and welcome to contribute any features/patches back
to this project!</p>

<h2 id="before-you-start">Before You Start</h2>

<ul>
<li>Make sure you understand the features of <em>HyperMake</em></li>
<li>Look at <a href="https://github.com/evo-cloud/hmake/issues">Github Issues</a> to see if
your feature request/issue has already been submitted</li>
<li>Be familiar with <a href="http://golang.org">Go development</a> and <a href="http://www.docker.com">Docker</a></li>
</ul>

<h2 id="submit-an-issue">Submit an Issue</h2>

<p>An issue can be a feature request or a bug. If possible please put on the
corresponding labels <code>feature</code>, <code>bug</code>, <code>enhancement</code> etc. And the maintainers
may alter the labels and put priority labels.</p>

<p><em>Features</em></p>

<p>Please clearly define the feature with as more details as possible to help others
easily understand the feature. For example, describing the detailed operation
steps, listing the example usage (command line) will be great help.</p>

<p><em>Bugs</em></p>

<p>In the title, please briefly describe the problem.
In the comment, please follow the structures below:</p>

<pre><code># Problem Description

Detailed problem description

# Environment

Platform: OS, version
Arch: CPU architecture
Version: hmake version

Other information...

# Reproduce Steps

Steps for reproducing the problem

# Attached Content

E.g. Content of your HyperMake file, project directory structure,
scripts when possible.
</code></pre>

<h2 id="submit-a-pull-request">Submit a Pull Request</h2>

<ul>
<li>Make sure there&rsquo;s a corresponding issue submitted in
<a href="https://github.com/evo-cloud/hmake/issues">Github Issues</a>, arbitrary pull
requests are unlikely to be accepted;</li>
<li>Make sure your code has been well formatted, vetted/linted and documented;</li>
<li>Include issue number in your short commit message (first line), like <code>#15</code>;</li>
<li>Tests must be included, depending on the change, End-to-End tests may be required;</li>
<li>Make sure there&rsquo;s a single commit.</li>
</ul>

<p><em>TIPS</em></p>

<blockquote>
<p>To run format check, vet and lint, you can simply use</p>

<pre><code>hmake check -v
</code></pre>

<p>To fix format, simply use</p>

<pre><code>go fmt -w DIR
</code></pre>
</blockquote>

<h2 id="dependencies-needed">Dependencies Needed</h2>

<ul>
<li>Git</li>
<li>A Github account</li>
<li>Go 1.6 or above: install from <a href="http://golang.org">golang.org</a></li>
<li>A list of Go dependencies:

<ul>
<li>gvt: <code>go get github.com/FiloSottile/gvt</code></li>
<li>ginkgo: <code>go get github.com/onsi/ginkgo/ginkgo</code></li>
<li>gomega: <code>go get github.com/onsi/gomega</code></li>
<li>hugo: <code>go get github.com/spf13/hugo</code>, if you want to generate sites</li>
</ul></li>
<li>For format, vet and lint

<ul>
<li>go tools: <code>go get golang.org/x/tools/cmd/...</code></li>
<li>metalinter: <code>go get -v github.com/alecthomas/gometalinter &amp;&amp; gometalinter --install</code></li>
</ul></li>
</ul>

<h2 id="steps-to-get-started">Steps to Get Started</h2>

<ol>
<li>Fork <code>github.com/evo-cloud/hmake</code> to your own account (assume <code>dev</code>)</li>
<li>Create a Go development environment, the following steps are recommended for
most people, especially for those new to Go:</li>
</ol>

<pre><code class="language-sh">   mkdir -p ~/workspace/go
   cd ~/workspace/go
   export GOPATH=`pwd`
   export PATH=&quot;$GOPATH/bin:$PATH&quot;
   go get github.com/FiloSottile/gvt
   go get github.com/onsi/ginkgo/ginkgo
   go get github.com/onsi/gomega
   mkdir -p src/github.com/evo-cloud
   git clone git@github.com:dev/hmake src/github.com/evo-cloud/hmake
   cd src/github.com/evo-cloud/hmake
   gvt restore
</code></pre>

<ol>
<li>Start developing</li>
</ol>

<pre><code class="language-sh">   cd ~/workspace/go/src/github.com/evo-cloud/hmake
   # and make sure environment variable GOPATH and PATH are properly set as above

   go build ./   # this will build ./hmake executable
   go install ./ # or if you want to install to $GOPATH/bin

   # make sure docker is running
   # if docker-machine is used (not for Linux)
   eval $(docker-machine env MACHINE-NAME)
   docker version # make sure both client and server versions are displayed

   ./hmake -sv # build all by default
   ./hmake check # check format, run lint
   ./hmake test # run tests
   ./hmake e2e # run end-to-end tests
   ./hmake cover # generate coverage

   # alternatively, use go directly
   go test ./test
   # or
   ginkgo ./test
   go test ./test/e2e
   # or
   ginkgo ./test/e2e
   go test -coverprofile=cover.out -coverpkg=./project ./test
</code></pre>

    </div>
    
</section>

                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/DockerDriver/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="the-docker-execution-driver">The <em>docker</em> Execution Driver</h1>

<p>This execution driver interprets commands or scripts and run inside the specified
docker container.</p>

<h2 id="properties">Properties</h2>

<ul>
<li><code>script</code>: a multi-line string represents a full script to execute inside the
container;
E.g.</li>
</ul>

<pre><code class="language-yaml">  targets:
      sample:
          script: |
              #!/bin/bash
              echo 'This is a bash script'
      sample1:
          script: |
              #!/usr/bin/env perl
              print &quot;a perl script&quot;
</code></pre>

<ul>
<li><code>cmds</code>: when <code>script</code> is not specified, this is a list of commands to execute
for the target; E.g.</li>
</ul>

<pre><code class="language-yaml">  targets:
      sample:
          cmds:
              - mkdir -p bin
              - gcc -o bin/hello hello.c
</code></pre>

<p>the list of commands is merged to generate a shell script:</p>

<pre><code class="language-sh">  #!/bin/sh
  set -e
  mkdir -p bin
  gcc -o bin/hello hello.c
</code></pre>

<ul>
<li><code>env</code>: a list of environment variables (the form <code>NAME=VALUE</code>) to be used for
execution (the <code>-e</code> option of <code>docker run</code>); E.g.</li>
</ul>

<pre><code class="language-yaml">  targets:
      sample:
          env:
              - ARCH=x86_64
              - OS=linux
              - RELEASE        # without =VALUE, the value is populated from
                               # current environment of hmake
</code></pre>

<ul>
<li><p><code>env-files</code>: list of files providing environment variables, see <code>--env-files</code>
of <code>docker run</code>;</p></li>

<li><p><code>console</code>: when <code>true</code>, the current stdin/stdout/stderr is directly passed to
command which is able to fully control the current console, equivalent to
<code>docker run -it</code>.
Default is false, equivalent to <code>docker run -a STDOUT -a STDERR</code>.</p></li>
</ul>

<p><em>NOTE: When enabled, no output is captured or logged.</em></p>

<ul>
<li><code>build</code>: path to <code>Dockerfile</code>, when specified, this target builds a docker
image first. <code>image</code> property specifies the image name and tag.
The value can point to a <code>Dockerfile</code> (e.g. <code>build: build/Dockerfile.arm</code>)
which indicates the folder containing the file is the context folder.
And the value can also point to a folder which contains a <code>Dockerfile</code>
(e.g. <code>build: build</code>) which uses the folder as context folder and looks for
<code>Dockerfile</code> there.</li>
</ul>

<p>It&rsquo;s strongly recommended to put <code>Dockerfile</code> and any related files to
   <code>watches</code> list;</p>

<ul>
<li><p><code>build-from</code>: the path of context folder for <code>docker build</code>.
Without this property, the path is derived from path of <code>Dockerfile</code> specified
in <code>build</code>. Please note, the path must be direct/indirect parent of the
<code>Dockerfile</code> as required by <code>docker build</code>;</p></li>

<li><p><code>build-args</code>: list of args, corresponding to <code>docker build</code> option;</p></li>

<li><p><code>image</code>: with <code>build</code> it&rsquo;s the image name and tag to build,
without <code>build</code>, it&rsquo;s the image used to create the container;</p></li>

<li><p><code>tags</code>: a list of tags in addition to <code>image</code> when do <code>docker build</code>;</p></li>

<li><p><code>commit</code>: commit running container into new image. Support multiple tags.
Image tag will be <code>latest</code>, if not self-defined in image name. E.g.</p></li>
</ul>

<pre><code class="language-yaml">  target:
      image: new-image-name:newtag
      cmds:
          &lt;Some commands&gt;
      commit:
            - new-image-name:tag1
            - new-image-name:tag2
</code></pre>

<ul>
<li><code>cache</code>: only used to specify <code>false</code> which adds <code>--no-cache</code> to <code>docker build</code>;</li>
<li><code>content-trust</code>: only used to specify <code>false</code> which adds
<code>--disable-content-trust</code> to <code>docker build/run</code>;</li>
<li><code>src-volume</code>: the full path inside container where project root is mapped to.
Default is <code>/src</code>;</li>
<li><code>expose-docker</code>: when set <code>true</code>, expose the host docker server connectivity
into container to allow docker client run from inside the container.
This is very useful when docker is required for build and avoid problematic
docker-in-docker;</li>
<li><code>privileged</code>: run container in privileged mode, default is <code>false</code>;</li>
<li><code>net</code>: when specified, only allowed value is <code>host</code>, when specified, run
container with <code>--net=host --uts=host</code>;</li>
<li><code>user</code>: passed to <code>docker run --user...</code>, by default, current <code>uid:gid</code> are
passed (with <em>docker-machine</em> the <code>uid:gid</code> is queried from the virtual machine
running docker daemon).
It must be explicitly specified <code>root</code> if the script is executed as root
inside container.
When a non-root user is explicitly specified, all group IDs are automatically
passed using <code>--group-add</code>l;</li>
<li><code>groups</code>: explicitly specify group IDs to pass into container, instead of
passing all of them;</li>
<li><code>volumes</code>: a list of volume mappings passed to <code>-v</code> option of <code>docker run</code>.</li>
</ul>

<p>The following properties directly maps to <code>docker build/run</code> options:</p>

<ul>
<li><code>cap-add</code>, <code>cap-drop</code></li>
<li><code>devices</code></li>
<li><code>hosts</code>: mapped to <code>--add-host</code></li>
<li><code>dns</code>, <code>dns-opts</code>, <code>dns-search</code></li>
<li><code>blkio-weight</code>, <code>blkio-weight-devices</code></li>
<li><code>device-read-bps</code>, <code>device-write-bps</code>, <code>device-read-iops</code>, <code>device-write-iops</code></li>
<li><code>cpu-shares</code>, <code>cpu-period</code>, <code>cpu-quota</code>, <code>cpuset-cpus</code>, <code>cpuset-mems</code></li>
<li><code>kernel-memory</code>, <code>memory</code>, <code>memory-swap</code>, <code>memory-swappiness</code>, <code>shm-size</code></li>
<li><code>ulimit</code></li>
<li><code>labels</code>, <code>label-files</code></li>
<li><code>pull</code>, <code>force-rm</code></li>
</ul>

<p>All above properties can also be specified in <code>settings</code>/<code>local</code> under
<code>docker</code> section:</p>

<pre><code class="language-yaml">settings:
    docker:
        property: value
</code></pre>

<h2 id="volume-mapping">Volume Mapping</h2>

<p>By default the current project root is mapped into container at <code>src-volume</code>,
default value is <code>/src</code>.
As the script is a shell script, the executable <code>/bin/sh</code> must be present in
the container.</p>

<p>The host side path is translated with the following rule:</p>

<ul>
<li>It&rsquo;s relative path, it&rsquo;s relative to working directory (property <code>workdir</code>);</li>
<li>It&rsquo;s absolute path (including starting with <code>~/</code>, <code>~</code> expands to home), it&rsquo;s absolute on the host;</li>
<li>It starts with <code>-/</code>, it&rsquo;s relative to project root.</li>
</ul>

<p>Example:</p>

<pre><code class="language-yaml">targets:
  volumes:
    - 'abc:/var/lib/abc'  # host path is $HMAKE_PROJECT_DIR/$HMAKE_TARGET_DIR/abc
    - '~/.ssh:/root/.ssh' # host path is $HOME/.ssh
    - '/var/lib:/var/lib' # host path is /var/lib
    - '-/src:/src'        # host path is $HMAKE_PROJECT_DIR/src
</code></pre>

<p><em>NOTE</em></p>

<p>On Mac OS, only paths under <code>/Users</code> can be mapped into the container.
All project trees must sit under <code>/Users</code>.</p>

<p>On Windows, only paths under <code>C:\Users</code> can be mapped into the container.
All project trees must sit under <code>C:\Users</code>.</p>

<h2 id="user">User</h2>

<p>By default <em>hmake</em> uses current user (NOT root) to run inside container,
which make sure any file change has the same ownership as the environment outside.
If root is required, it can be explicitly specified <code>user: root</code>,
however, all files created inside container will be owned by <code>root</code> outside,
and you may eventually see some error messages like <code>permission denied</code> when you
do something outside.</p>

<h2 id="limits">Limits</h2>

<p>On Linux, <em>docker-machine</em> is not supported, docker daemon must run on the same
host running <em>hmake</em>.</p>

    </div>
    
</section>

                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/FAQ/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="questions-and-best-practices">Questions and Best Practices</h1>

<ul>
<li><p><strong>Q</strong>: Why I can&rsquo;t <code>git clone</code> private repositories?<br>
<strong>A</strong>: HyperMake runs the build inside containers which may not have the right
SSH keys or credentials. There&rsquo;re two options:</p>

<ul>
<li>Mapping <code>~/.ssh</code> into the container using <code>volumes</code> property:</li>
</ul>

<pre><code class="language-yaml">volumes:
  - '~/.ssh:/src/.ssh:ro'
</code></pre>

<ul>
<li>Mapping <code>~/.netrc</code> into the container:</li>
</ul>

<p>first, create a file <code>~/.netrc</code>. See the
<a href="https://www.gnu.org/software/inetutils/manual/html_node/The-_002enetrc-file.html">manual</a>
for the format and content. E.g.</p>

<pre><code>machine github.com
protocol https
login username
password password
</code></pre>

<p>Then use <code>volumes</code> property to map into the container.</p>

<pre><code class="language-yaml">volumes:
  - '~/.netrc:/src/.netrc:ro'
</code></pre></li>

<li><p><strong>Q</strong>: Can I build projects for Windows?<br>
<strong>A</strong>: Depending on toolchain. HyperMake builds on Linux, for C/C++,
install <a href="http://www.mingw.org">mingw</a> toolchain in the container and do
the cross complication.</p></li>

<li><p><strong>Q</strong>: Can I build projects for native Mac OS?<br>
<strong>A</strong>: Depending. If it&rsquo;s a project in Go, yes. If it depends on native Mac OS
libraries, it&rsquo;s possible when cross compiling toolchain and libraries are
installed on Linux.</p></li>

<li><p><strong>Q</strong>: Why target is skipped but output file is not present?<br>
<strong>A</strong>: Property <code>artifacts</code> is not specified in the target. <em>HyperMake</em> checks
both input and output files to determine if a target is up-to-date. Property
<code>watches</code> lists the input files whose last modification time is checked, and
property <code>artifacts</code> lists the output files whose presence is checked.
If <code>artifacts</code> is not specified, <em>HyperMake</em> assumes the target doesn&rsquo;t generate
output files.</p></li>

<li><p><strong>Q</strong>: What&rsquo;s the <code>artifacts</code> if the target doesn&rsquo;t output files?<br>
<strong>A</strong>: No need to specify <code>artifacts</code> if there&rsquo;s no output file. Some targets
like docker build doesn&rsquo;t output files, it will automatically check if the
image exists. To explicitly rebuild the target, use <code>-r TARGET</code>, <code>-b</code> or <code>-R</code>
options.</p></li>

<li><p><strong>Q</strong>: I want to run some commands, which are specific to my local environment,
before certain targets. But I don&rsquo;t want to put them in <code>HyperMake</code> file.<br>
<strong>A</strong>: You can create a <code>.hmakerc</code> in project root, and exclude that file using
<code>.gitignore</code>. The <code>settings</code> in <code>.hmakerc</code> will override those in <code>HyperMake</code>
and use <code>before</code> to inject your local targets into <code>HyperMake</code>, e.g.</p></li>
</ul>

<pre><code class="language-yaml">  ---
  format: hypermake.v0
  targets:
    pre-build:
      description: my local task before build
      before:
        - build
      cmds:
        - do something
  settings:
    property: my-value
</code></pre>

<ul>
<li><strong>Q</strong>: How to map a volume from a folder relative to project root?<br>
<strong>A</strong>: In top-level <code>HyperMake</code>, use relative path for source of the volume,
in <code>*.hmake</code> files under sub-directories, prefix <code>-/</code> to a relative path. E.g.</li>
</ul>

<pre><code class="language-yaml">  targets:
    example:
      volumes:
        - '-/run:/var/run'
</code></pre>

<p>Anyway, in <code>volumes</code>, prefix <code>-/</code> can always be used to indicate a path
  relative to project root. Please read <a href="/hmake/docs/DockerDriver/">Docker Driver</a> for
  details.</p>

<ul>
<li><p><strong>Q</strong>: Where can I find the output of my target after running <code>hmake</code>?<br>
<strong>A</strong>: <code>hmake</code> creates a hidden folder <code>.hmake</code> under project root. The output
of a target is saved in <code>.hmake/TARGET.log</code>.</p></li>

<li><p><strong>Q</strong>: Does <code>hmake</code> print logs?<br>
<strong>A</strong>: Yes. <code>hmake</code> writes its own debug logs in <code>.hmake/hmake.debug.log</code>.</p></li>

<li><p><strong>Q</strong>: What&rsquo;re the recommended entries in <code>.gitignore</code>?<br>
<strong>A</strong>: Put the following entries in <code>.gitignore</code>:</p></li>
</ul>

<pre><code>  .hmake
  .hmakerc
</code></pre>

    </div>
    
</section>

                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/FileFormat/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="hypermake-file-format">HyperMake File Format</h1>

<p>File <code>HyperMake</code> must be present in root directory of the project tree. Command
<code>hmake</code> can be invoked in any sub-directories inside the project tree and it will
locate the root of project by looking up <code>HyperMake</code>.
Additional files must be named as <code>*.hmake</code> for being referenced in <code>includes</code>
section.
All these files share the same format.</p>

<p>In <code>HyperMake</code> or <code>*.hmake</code>, define the following things:</p>

<ul>
<li>Format: the format presents the current file, should always be <code>hypermake.v0</code>;</li>
<li>Name and description: only defined in top-level <code>HyperMake</code> file;</li>
<li>Targets: the target to build, including dependencies and commands;</li>
<li>Settings: the settings applies to <em>hmake</em> and should be merged into a global view;</li>
<li>Local Settings: the settings only apply to current <code>HyperMake</code> or <code>.hmake</code> file;</li>
<li>Includes: include more <code>*.hmake</code> files.</li>
</ul>

<p>Here&rsquo;s the schema in example (this is from the <code>HyperMake</code> file of <code>hmake</code> project):</p>

<pre><code class="language-yaml">---
format: hypermake.v0 # this indicates this is a HyperMake file

# project name and description
name: hmake
description: HyperMake builds your project without pre-requisites

# define targets
targets:
    builder:
        description: build the docker image including toolchain
        build: builder
        image: hmake-builder:latest
        watches:
            - builder

    vendor:
        description: pull all vendor packages
        after:
            - builder
        watches:
            - 'vendor/manifest'
        cmds:
            - gvt restore

    hmake-linux-amd64:
        description: static linked hmake binary for Linux AMD64
        after:
            - vendor
        watches:
            - '**/**/*.go'
            - build.sh
        cmds:
            - ./build.sh linux amd64
        artifacts:
            - bin/linux/amd64/hmake
            - bin/hmake-linux-amd64.tar.gz
            - bin/hmake-linux-amd64.tar.gz.sha256sum

    hmake-darwin-amd64:
        description: static linked hmake binary for Mac OS
        after:
            - vendor
        watches:
            - '**/**/*.go'
            - build.sh
        cmds:
            - ./build.sh darwin amd64
        artifacts:
            - bin/darwin/amd64/hmake
            - bin/hmake-darwin-amd64.tar.gz
            - bin/hmake-darwin-amd64.tar.gz.sha256sum

    hmake-windows-amd64:
        description: static linked hmake binary for Windows
        after:
            - vendor
        watches:
            - '**/**/*.go'
            - build.sh
        cmds:
            - ./build.sh windows amd64
        artifacts:
            - bin/windows/amd64/hmake.exe
            - bin/hmake-windows-amd64.zip
            - bin/hmake-windows-amd64.zip.sha256sum

    site:
        description: generate document site
        after:
            - builder
        watches:
            - site/gh-pages/config.toml
            - site/gh-pages/themes/**/**/*
            - site/gh-pages/static/**/**/*
            - README.md
            - docs/**/**/*
            - examples/*/README.md
            - build.sh
        cmds:
            - ./build.sh gensite

    checkfmt:
        description: check code format
        after:
            - builder
        always: true
        cmds:
            - ./build.sh checkfmt

    lint:
        description: check code using metalint
        after:
            - builder
        always: true
        cmds:
            - ./build.sh lint

    check:
        description: check source code
        after:
            - checkfmt
            - lint

    test:
        description: run tests
        after:
            - vendor
        always: true
        cmds:
            - ginkgo ./test

    cover:
        description: run tests with coverage
        after:
            - vendor
        always: true
        cmds:
            - &gt;
                go test -coverprofile cover.out
                -coverpkg ./project
                ./test

    e2e:
        description: end-to-end tests
        after:
            - vendor
        expose-docker: true
        always: true
        cmds:
            - ginkgo ./test/e2e

    all:
        description: the default make target
        after:
            - hmake-linux-amd64
            - hmake-darwin-amd64
            - hmake-windows-amd64

# settings shared across targets
settings:
    default-targets:
        - all
    docker:
        image: hmake-builder:latest
        src-volume: /go/src/github.com/evo-cloud/hmake

# same as settings, but only apply to targets in the same file
local:
    key: value

includes:
    - build/**/**/*.hmake
</code></pre>

<h2 id="format">Format</h2>

<p>The format of this <code>YAML</code> file is indicated by <code>format</code> property which is
mandatory and the current acceptable value is <code>hypermake.v0</code></p>

<h2 id="name-and-description">Name and Description</h2>

<p>These are optional properties, while it&rsquo;s recommended <code>name</code> should be provided
as project name.</p>

<h2 id="targets">Targets</h2>

<p>The property <code>targets</code> defines a dictionary of named targets.
A target is a set of properties to define what to do (a script or a list of commands).
Usually, it defines</p>

<ul>
<li>The environment to execute the script/commands,
like docker image, workdir, and options for <code>docker run</code>;</li>
<li>The dependencies between targets, using <code>before</code> and <code>after</code> properties;</li>
<li>Watch of files to decide whether the target should be rebuilt.</li>
</ul>

<h4 id="common-properties-in-target">Common Properties in Target</h4>

<ul>
<li><code>description</code>: description of the target;</li>
<li><code>before</code>: a list of names of targets which can only execute after this target;</li>
<li><code>after</code>: a list of names of targets on which this targets depends;</li>
<li><code>workdir</code>: the current working directory for commands in the target,
relative to <code>.hmake</code> file defining the target;
if it&rsquo;s absolute (starting with <code>/</code>), it&rsquo;s relative to project root;
by default, it&rsquo;s the current directory containing the <code>.hmake</code> file.</li>
<li><code>watches</code>: a list of path/filenames (wildcard supported) whose mtime will be
checked to determine if the target is out-of-date, without specifying this
property, the target is automatically skipped if the last execution was successful
and all dependencies are skipped;</li>
<li><code>always</code>: always build the target regardless of last execution state and results
of all dependencies (the <code>.PHONY</code> target in <code>make</code>);</li>
<li><code>artifacts</code>: a list of files/directory must be present after the execution of
the target (aka. the output of the target), in relative path to current <code>.hmake</code>
file, or if it&rsquo;s absolute path, it&rsquo;s relative to project root.</li>
</ul>

<p>Other properties are specific to execution driver which executes the target.
The currently supported execution driver is <code>docker</code>, please read
<a href="/hmake/docs/DockerDriver/">Docker Driver</a> for details.</p>

<h4 id="dependencies">Dependencies</h4>

<p>Dependencies are specified using:</p>

<ul>
<li><code>after</code>: the target is executed when the depended tasks succeed or are skipped</li>
<li><code>before</code>: the target must succeed or skip before the specified tasks get executed.</li>
</ul>

<p>A <em>skipped</em> target means there&rsquo;s nothing to do with the target (no commands or
it&rsquo;s still up-to-date). It can be an equivalent to <em>success</em>.</p>

<p>In most cases, <code>after</code> is enough. <code>before</code> is often used to inject dependencies.</p>

<h4 id="matching-targets-names-with-wildcards">Matching targets names with wildcards</h4>

<p>The places (<code>before</code>, <code>after</code>, <code>-r</code>, <code>-S</code>, command line targets, etc) requiring
target names accept wildcards:</p>

<ul>
<li>Wildcards used in file names: <code>*</code>, <code>?</code>, <code>\</code> and <code>[chars]</code>, they are matched using <code>filepath.Match</code></li>
<li>Regular Expression: the name starts and ends with <code>/</code></li>
</ul>

<h4 id="pre-defined-environment-variables">Pre-defined Environment Variables</h4>

<ul>
<li><code>HMAKE_PROJECT_NAME</code>: the name of the project</li>
<li><code>HMAKE_PROJECT_DIR</code>: the directory containing <code>HyperMake</code> (aka. project root)</li>
<li><code>HMAKE_PROJECT_FILE</code>: the full path to <code>HyperMake</code></li>
<li><code>HMAKE_WORK_DIR</code>: <code>$HMAKE_PROJECT_DIR/.hmake</code></li>
<li><code>HMAKE_LAUNCH_PATH</code>: the relative path under <code>$HMAKE_PROJECT_DIR</code> where <code>hmake</code> launches</li>
<li><code>HMAKE_REQUIRED_TARGETS</code>: the names of targets explicitly required from command line, separate by space</li>
<li><code>HMAKE_TARGET</code>: the name of the target currently in execution</li>
<li><code>HMAKE_TARGET_DIR</code>: the relative path to directory containing the file which defines the target</li>
<li><code>HMAKE_VERSION</code>: version of <em>hmake</em></li>
<li><code>HMAKE_OS</code>: operating system</li>
<li><code>HMAKE_ARCH</code>: CPU architecture</li>
</ul>

<h2 id="include-files">Include Files</h2>

<p>In <code>includes</code> section, specify files to be included.
The files included can provide more targets and also override settings.</p>

<p>Any path used in <code>HyperMake</code> or <code>*.hmake</code> files are relative to current file.
When a target gets executed, the default working directory is where the file
defining the target exists.</p>

<h2 id="settings">Settings</h2>

<p>In <code>settings</code> section, the hierarchical dictionary is used to provide
global settings. According to the order of <code>*.hmake</code> files loaded, the file loaded
latter overrides the settings in the former loaded files.
In <code>local</code> section, the settings are only applied to current file.
And the properties defined in target overrides everything.</p>

<p>Here&rsquo;s the order <em>hmake</em> looks a setting by name:</p>

<ul>
<li>From target&rsquo;s properties;</li>
<li>From <code>local</code>;</li>
<li>From <code>settings</code> in the reversed order of files being loaded.</li>
</ul>

<h4 id="pre-defined-setting-properties">Pre-defined Setting Properties</h4>

<ul>
<li><code>default-targets</code>: a list of targets to build when no targets are specified
in <code>hmake</code> command;</li>
<li><code>docker</code>: a set of <a href="/hmake/docs/DockerDriver/">docker</a> specific properties which defines
default values for targets.</li>
</ul>

<h2 id="local-customization">Local Customization</h2>

<p>After loading <code>HyperMake</code> and <code>*.hmake</code> files, <em>hmake</em> also looks up <code>.hmakerc</code>
files from current directory up to root directory of the project and load them
in the order from root directory down to the current directory.
The <code>.hmakerc</code> has the same format as <code>HyperMake</code> and <code>*.hmake</code> files and is
used to override settings and inject targets to satisfy the special needs of
local development environment.
<code>.hmakerc</code> should be included in <code>.gitignore</code> file.</p>

    </div>
    
</section>

                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/QuickStart/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="quick-start-guide">Quick Start Guide</h1>

<p>This is a guide to write a HyperMake file for your project for the first time.</p>

<h2 id="before-start">Before Start</h2>

<p>You need a project, of course. Let&rsquo;s make a simple <em>Hello World</em> C++ project,
and see how HyperMake can help.</p>

<p>Here&rsquo;s the project directory layout:</p>

<pre><code>ProjectRoot
  |
  +--inc/
  +--src/
      +--hello.cpp
</code></pre>

<p>In <code>hello.cpp</code>:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

int main(int argc, char *argv[]) {
    std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>To build it, use <code>g++ -o hello src/hello.cpp</code>. You will need toolchain installed.
Now, let&rsquo;s create a <code>HyperMake</code> to simplify the build.</p>

<h2 id="create-hypermake">Create <code>HyperMake</code></h2>

<p><code>HyperMake</code> can be composed in two ways:</p>

<ul>
<li>Wrapper mode: which wraps existing build tools, like GNU make</li>
<li>Full mode: the native HyperMake format with all features.</li>
</ul>

<p>For <em>Wrapper mode</em>, read details in <a href="/hmake/docs/WrapperMode/">Wrapper Mode</a>.
In this guide, we will use <em>Full mode</em>.</p>

<p>Create a file called <code>HyperMake</code> under <code>ProjectRoot</code>.
It&rsquo;s a <em>YAML</em> file, so let&rsquo;s start with:</p>

<pre><code class="language-yaml">---
format: hypermake.v0
name: hello
description: The Hello World Project
</code></pre>

<p>The first line <code>---</code> is optional but recommended, as YAML parser will treat it
as the beginning of a new document.</p>

<p><code>format</code> is required and must be assigned with <code>hypermake.v0</code>.
<em>hmake</em> only parses YAML files with <code>format: hypermake.v0</code>.
<code>name</code> specifies the project name, which is required.
<code>description</code> gives more information about the project. It&rsquo;s optional.</p>

<h2 id="adding-targets">Adding targets</h2>

<p>The most important part is the section defining targets:</p>

<pre><code class="language-yaml">---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  build:
    description: build hello binary
    image: 'gcc:4.9'
    cmds:
      - g++ -o hello src/hello.cpp
</code></pre>

<p>We defined one target above: <code>build</code>. It has three properties:</p>

<ul>
<li><code>description</code>: a brief intro about what the target does;</li>
<li><code>image</code>: the docker image used to create the container and run commands;</li>
<li><code>cmds</code>: a list of commands to execute inside the container.</li>
</ul>

<p>Now, we can use <code>hmake build</code> to build the project, and type</p>

<pre><code>./hello
</code></pre>

<p>to show <code>Hello World</code>.</p>

<p>Under the hood, <code>hmake</code> creates a container temporarily, and maps current project
root to <code>/src</code> inside container and run the commands inside the container.</p>

<p>Are you feeling boring type <code>hmake build</code> every time? Why not just <code>hmake</code>?
Let&rsquo;s move on with default targets.</p>

<h2 id="settings">Settings</h2>

<p>The default targets can be specified inside <code>settings</code> section:</p>

<pre><code class="language-yaml">---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  build:
    description: build hello binary
    image: 'gcc:4.9'
    cmds:
      - g++ -o hello src/hello.cpp

settings:
  default-targets:
    - build
</code></pre>

<p>With <code>default-targets</code> specified in <code>settings</code>, we can type <code>hmake</code> without
arguments and it will run targets defined in <code>default-targets</code>.</p>

<p>The <code>settings</code> section defines properties which are common to all targets.
For example, we can define common properties for <code>docker</code>. Let&rsquo;s move <code>image</code>
property to settings:</p>

<pre><code class="language-yaml">---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  build:
    description: build hello binary
    cmds:
      - g++ -o hello src/hello.cpp

settings:
  default-targets:
    - build
  docker:
    image: 'gcc:4.9'
</code></pre>

<p>As we moved <code>image</code> to <code>settings/docker</code>, we can remove <code>images</code> from target
<code>build</code>. And all targets will have <code>image: 'gcc:4.9'</code> by default.</p>

<h2 id="watches-and-artifacts">Watches and Artifacts</h2>

<p>Let&rsquo;s do some tricks here: <code>touch src/hello.cpp</code> or modify the file, and then
type <code>hmake</code>. You will see the <code>build</code> target is skipped:</p>

<pre><code>HyperMake v1.1.0 https://github.com/evo-cloud/hmake

=&gt; build 21:56:42.277
:] build
╔══════╤═══════╤════════╤════════════╤════════════╤═════╗
║Target│Result │Duration│Start       │Finish      │Error║
╠══════╪═══════╪════════╪════════════╪════════════╪═════╣
║build │Skipped│        │21:56:42.277│21:56:42.277│     ║
╚══════╧═══════╧════════╧════════════╧════════════╧═════╝
OK
</code></pre>

<p>This is definitely not what we want. The problem is <em>hmake</em> doesn&rsquo;t know which
files are input and which are output. Let&rsquo;s tell <em>hmake</em> by adding <code>watches</code> and
<code>artifacts</code> to target <code>build</code>:</p>

<pre><code class="language-yaml">targets:
  build:
    description: build hello binary
    watches:
      - inc
      - src
    cmds:
      - g++ -o hello src/hello.cpp
    artifacts:
      - hello
</code></pre>

<p>The items in <code>watches</code> can be a path to a directory or a file, or with wildcards
matching a list of files/directories. If the item is a directory, all sub-directories
and files are watched recursively.
<code>artifacts</code> lists the output files. <em>hmake</em> rebuilds the target if any of the
artifacts is missing. Wildcard is not allowed here, and directory is not matched
recursively.</p>

<p>Some targets doesn&rsquo;t require input files or generate output files. In this case
command line options can be used to explicitly rebuild the target: <code>-R</code>, <code>-r</code>, or
<code>-b</code>. See <a href="/hmake/docs/CommandLine/">Command Line</a> for details.</p>

<h2 id="dependencies">Dependencies</h2>

<p>As the project is so simple that we can use an existing docker image <code>gcc:4.9</code> which
contains toolchain we need.
However in most cases, the existing docker images are not always good enough, and
we want to install extra bits to build the project.
Then we need to build our own toolchain image.</p>

<p>Let&rsquo;s use <code>cmake</code> to build our project, by adding <code>CMakeList.txt</code> under project root:</p>

<pre><code>cmake_minimum_required(VERSION 2.8.0)
project(hello CXX)
include_directories(&quot;inc&quot;)
add_executable(hello src/hello.cpp)
</code></pre>

<p>Then we will need <code>cmake</code> in toolchain image, let&rsquo;s build one based on <code>gcc:4.9</code>.
Create a folder <code>toolchain</code> under project root and put a <code>Dockerfile</code> inside it:</p>

<pre><code>FROM gcc:4.9
RUN apt-get update &amp;&amp; apt-get install -y cmake &amp;&amp; apt-get clean
</code></pre>

<p>And update <code>HyperMake</code>:</p>

<pre><code class="language-yaml">---
format: hypermake.v0
name: hello
description: The Hello World Project

targets:
  toolchain:
    description: build our own toolchain image
    watches:
      - toolchain
    build: toolchain

  build:
    description: build hello binary
    after:
      - toolchain
    watches:
      - inc
      - src
    cmds:
      - rm -fr rel &amp;&amp; mkdir -p rel
      - cd rel &amp;&amp; cmake .. &amp;&amp; make
    artifacts:
      - rel/hello

settings:
  default-targets:
    - build
  docker:
    image: 'cmake-gcc:4.9'
</code></pre>

<p>Target <code>toolchain</code> is added, with property <code>build</code>, <em>hmake</em> knows to build a
docker image, using <code>toolchain/Dockerfile</code>. And as <code>image: cmake-gcc:4.9</code> is specified
in <code>settings</code>, the built image will be <code>cmake-gcc:4.9</code>.</p>

<p>In target <code>build</code>, <code>after</code> specifies <code>toolchain</code> must succeed before <code>build</code> is able
to run. Because <code>build</code> will use the image <code>cmake-gcc:4.9</code> generated by <code>toolchain</code>.</p>

<p>Now, type <code>hmake</code> and it will first run <code>toolchain</code> to build <code>cmake-gcc:4.9</code> and
the run <code>build</code> to call <code>cmake</code> to build the binary.</p>

<h2 id="more">More</h2>

<p>The above covers the basic features of <em>HyperMake</em>.
There are a lot more useful features.
Please read documents listed in <a href="/hmake/README/">README</a> for more details, and take
a look at <code>examples</code> for real samples.</p>

    </div>
    
</section>

                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/UseCases/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="how-hypermake-helps-make-life-easier">How HyperMake Helps Make Life Easier</h1>

<h2 id="on-board-new-team-member">On-board New Team Member</h2>

<p>Most software projects have complicated requirements to setup a development
environment. There are always a list of software to install, including a
specific version of toolchain, specific versions of libraries, etc.</p>

<p>The new member on-board experience often suffers, and usually takes days up to
weeks.</p>

<p>With <em>HyperMake</em>, the on-board experience is simplest. The new member only need
to install <a href="https://www.docker.com">docker</a> and <code>hmake</code> executable.
Then the project will be built smoothly.</p>

<h2 id="deliver-an-open-source-project">Deliver an Open Source Project</h2>

<p><em>Compiling from source</em> is challenging work for most of people.
However, it&rsquo;s unavoidable if new features are required and a pre-built package is
not available.
If the project is built using <em>HyperMake</em>, it makes <em>compiling from source</em> the
simplest thing on the world.</p>

<h2 id="build-test-product-consistently">Build/Test Product Consistently</h2>

<p>People often complain <em>environment issue</em> when building/testing a software product.
Because the <em>environments</em> (toolchain, libraries) can&rsquo;t always be identical from
developer to developer. Things work fine in one environment will likely be
broken in another environment.
With help of <em>HyperMake</em>, the product is always built/tested in a clean and consistent
way because the same docker image is used across all different environments.</p>

<h2 id="platform-independent-development">Platform-independent Development</h2>

<p>With <em>HyperMake</em>, it no longer requires developers work on specific platform.
As long as the project can be built on Linux, the developer is free to choose working
on Linux/Mac OS/Windows.</p>

    </div>
    
</section>

                
                
<section class="post">
    <header class="post-header">

        <a href="http://evo-cloud.github.com/hmake/docs/WrapperMode/" class="post-title"></a>

        <p class="post-meta">
            
            
        </p>
    </header>
    
    <div class="post-description">
        

<h1 id="hypermake-wrapper-mode">HyperMake Wrapper Mode</h1>

<p>The <em>Wrapper Mode</em> is the most quick and simplest way to adopt <em>HyperMake</em>
with existing projects which already has full build system, like GNU make.</p>

<h2 id="one-line-just-works">One line, just works!</h2>

<pre><code>echo '#hmake-wrapper dockcross/linux-armv7' &gt;HyperMake
hmake
</code></pre>

<p>The magic word <code>#hmake-wrapper</code> in the beginning of <code>HyperMake</code> file indicates
the <em>Wrapper Mode</em> of <em>HyperMake</em>.
It runs <code>make</code> inside container created from image <code>dockcross/linux-armv7</code>.</p>

<h2 id="wrapper-mode-file-format">Wrapper Mode File Format</h2>

<h3 id="first-line">First Line</h3>

<pre><code>#hmake-wrapper IMAGE Dockerfile-FOR-BUILD BUILD-ARGS
</code></pre>

<ul>
<li><code>IMAGE</code>: required, the docker image used to create the container;</li>
<li><code>Dockerfile-FOR-BUILD</code>: optional, relative path to a folder containing
<code>Dockerfile</code>,  or full path to file if it&rsquo;s not named <code>Dockerfile</code>.
When this is present, <code>IMAGE</code> is built locally from the <code>Dockerfile</code> before
run the wrapped build tool;</li>
<li><code>BUILD-ARGS</code>: optional, space separated <code>KEY=VALUE</code> directly passed to
<code>--build-args</code> option of <code>docker build</code> command.</li>
</ul>

<p>E.g.</p>

<pre><code>#hmake-wrapper mytoolchain-armhf toolchain/Dockerfile.armhf ARCH=armhf
</code></pre>

<h3 id="second-line">Second Line</h3>

<p>If <code>HyperMake</code> only contains the first line, the wrapped build tool is assumed
to be <code>make</code>. The following command <code>hmake</code> will run <code>make</code> inside the container
passing all command line arguments to <code>make</code>.</p>

<p>If there are additional lines in the file, the rest of the lines are written to
a script file, and <code>hmake</code> run this script file inside the container, passing
all command line arguments to this script file.</p>

<p>By default, the script file is generated with <code>#!/bin/sh</code> as first line, and then
filled with the rest lines in <code>HyperMake</code>.</p>

<p>E.g.</p>

<pre><code>#hmake-wrapper mytoolchain-armhf toolchain/Dockerfile.armhf ARCH=armhf
set -ex
exec ./build.sh &quot;$@&quot;
</code></pre>

<p>With this, <code>hmake</code> will invoke a script inside container like:</p>

<pre><code>#!/bin/sh
set -ex
exec ./build.sh &quot;$@&quot;
</code></pre>

<p>However, we may not always use shell scripts.
It&rsquo;s possible to write in any scripting language when the second line is explicitly
specified:</p>

<pre><code>#hmake-wrapper mytoolchain-armhf toolchain/Dockerfile.armhf ARCH=armhf
#!/usr/bin/env python
import sys
print(sys.argv)
</code></pre>

<h2 id="easy-huh">Easy! Huh?</h2>

<p>To utilize full features of <em>HyperMake</em>, the native <a href="/hmake/docs/FileFormat/">File Format</a>
is recommended.</p>

    </div>
    
</section>

                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Pages generated by <a class="hugo" href="https://gohugo.io/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://evo-cloud.github.com/hmake//js/jquery.min.js"></script>
<script src="http://evo-cloud.github.com/hmake//js/jquery.prettysocial.min.js"></script>
<script src="http://evo-cloud.github.com/hmake//js/rainbow-custom.min.js"></script>
<script src="http://evo-cloud.github.com/hmake//js/scripts.js"></script>

        </div>
    </div>
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        
        
        
        <hgroup>
            <h1 class="brand-title"><a href="https://github.com/evo-cloud/hmake/releases">Releases</a></h1>
            
            <h2 class="brand-tagline">
                <a href="https://github.com/evo-cloud/hmake/releases/tag/v1.1.1">1.1.1</a>
            </h2>
            
        </hgroup>
        
        <nav class="nav">
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/evo-cloud/hmake/releases/download/v1.1.1/hmake-linux-amd64.tar.gz">
                        <i class="os fa fa-linux"></i>
                        <span>linux</span>
                    </a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/evo-cloud/hmake/releases/download/v1.1.1/hmake-darwin-amd64.tar.gz">
                        <i class="os fa fa-apple"></i>
                        <span>Mac OS X</span>
                    </a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/evo-cloud/hmake/releases/download/v1.1.1/hmake-windows-amd64.zip">
                        <i class="os fa fa-windows"></i>
                        <span>windows</span>
                    </a>
                </li>
                
            </ul>
        </nav>
        
    </div>
</div>

</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
